<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2020 ACM ICPC, Asia Shanghai Regional</title>
    <url>/2021/02/22/2020-ACM-ICPC-Asia-Shanghai-Regional/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th style="text-align:center">solved</th>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">C</th>
<th style="text-align:center">D</th>
<th style="text-align:center">E</th>
<th style="text-align:center">F</th>
<th style="text-align:center">G</th>
<th style="text-align:center">H</th>
<th style="text-align:center">I</th>
<th style="text-align:center">J</th>
<th style="text-align:center">K</th>
<th style="text-align:center">L</th>
<th style="text-align:center">M</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">6 / 13</td>
<td style="text-align:center">·</td>
<td style="text-align:center">O</td>
<td style="text-align:center">·</td>
<td style="text-align:center">Ø</td>
<td style="text-align:center">·</td>
<td style="text-align:center">·</td>
<td style="text-align:center">O</td>
<td style="text-align:center">·</td>
<td style="text-align:center">Ø</td>
<td style="text-align:center">·</td>
<td style="text-align:center">·</td>
<td style="text-align:center">Ø</td>
<td style="text-align:center">O</td>
</tr>
</tbody>
</table>
<ul>
<li>O：比赛时通过</li>
<li>Ø：赛后通过</li>
<li>!：比赛时尝试了未通过</li>
<li>·：比赛时未尝试</li>
</ul>
<h2><span id="比赛链接"> </span></h2>
<span id="more"></span>
<h1><span id="b-mine-sweeper-ii"> B. Mine Sweeper II</span></h1>
<p>solved by lllllan. 2:05(+1)</p>
<p><strong>题意</strong> 在一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>∗</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n*m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>的扫雷地图中，‘<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>’表示地雷‘<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.10556em;vertical-align:0em;"></span><span class="mord">.</span></span></span></span>’表示没有地雷，没有地雷的方格上的数值为四周八个方格中含地雷的个数。现给出两个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>∗</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n*m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>扫雷的地图，要求将第二个地图通过不多于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>∗</mo><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n*m/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord">/</span><span class="mord">2</span></span></span></span>的操作次数【每次操作可将‘<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>’更改为‘<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.10556em;vertical-align:0em;"></span><span class="mord">.</span></span></span></span>’，或将’<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.10556em;vertical-align:0em;"></span><span class="mord">.</span></span></span></span>‘更改为’<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>‘】，使得变换后的地图中的权值和与第一个地图相等，输出变换后的地图。</p>
<p><strong>题解</strong> 操作次数刚好限制为地图方格个数的一半，然后考虑极端情况，两个地图完全一致，权值和必然相同；两个地图完全相反，权值和也相同。所以只要数出两个地图不同方格的个数，考虑将第二地图变换成和第一地图完全一致还是完全相反。最后特判<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>∗</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1*1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的地图即可。</p>
<details>
    <summary>AC代码</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> a[N][N], b[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, a[i] + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, b[i] + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a[i][j] != b[i][j]) cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (cnt &gt; (n * m / <span class="number">2</span>)) flag = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span> &amp;&amp; m == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, b[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, a[i] + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, a[i][j] == <span class="string">&#x27;.&#x27;</span> ? <span class="string">&#x27;X&#x27;</span> : <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</details>
<hr>
<h1><span id="d-walker"> D. Walker</span></h1>
<p>Solved By Sstee1XD. (-)</p>
<p><strong>题意</strong> 给你一条坐标从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>开始的水平线，再给你两个点各自的横坐标和速度，每个点可以任意移动，问最短的时间让两个点遍历完整条线段。</p>
<p><strong>题解</strong> 分类讨论，合并情况后发现可以分成三种情况。</p>
<ul>
<li>让一个点走完全程</li>
<li>两个点往对方的的方向走（对穿），走到尽头</li>
<li>两个点各自走完自己的线段，在中间相遇。其中每个点又有两种情况，可以先走中间，或者先走到自己这边的尽头。</li>
</ul>
<p>对于前两种情况可以直接求，第三种情况不好确定相遇点，所以考虑二分时间，对于两个点都选择能让自己多走中间线段的方案，相加判断长度。</p>
<details>
    <summary>AC代码</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> double long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg(x...) do &#123; cout <span class="meta-string">&lt;&lt; #x &lt;&lt; &quot; -&gt; &quot;; err(x); &#125; while (0)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span>... <span class="title">Ts</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(<span class="keyword">const</span> T&amp; arg, <span class="keyword">const</span> Ts&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; arg &lt;&lt; <span class="string">&#x27; &#x27;</span>; err(args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f = <span class="number">0</span>; x = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = getchar()) f |= (ch == <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = getchar()) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-11</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> tot, p1, p2, v1, v2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sgn</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(y - x) &lt;= eps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 前后两种分别是先走中间和先走到尽头的情况</span></span><br><span class="line">    <span class="keyword">double</span> d1 = max((t - p1 / v1) * v1 / <span class="number">2</span>, (t - <span class="number">2</span> * p1 / v1) * v1);</span><br><span class="line">    <span class="keyword">double</span> d2 = max((t - (tot - p2) / v2) * v2 / <span class="number">2</span>, (t - <span class="number">2</span> * (tot - p2) / v2) * v2);</span><br><span class="line">    <span class="keyword">if</span> (d1 &lt; <span class="number">0</span> || d2 &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> d1 + d2 &gt;= p2 - p1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; tot &gt;&gt; p1 &gt;&gt; v1 &gt;&gt; p2 &gt;&gt; v2;</span><br><span class="line">    <span class="keyword">if</span> (p2 &lt; p1) swap(p1, p2), swap(v1, v2);</span><br><span class="line">    <span class="keyword">double</span> ans = inf;</span><br><span class="line"></span><br><span class="line">    ans = min(ans, (min(p1, tot - p1) + tot) / v1); <span class="comment">// only one point</span></span><br><span class="line">    ans = min(ans, (min(p2, tot - p2) + tot) / v2);</span><br><span class="line"></span><br><span class="line">    ans = min(ans, max((tot - p1) / v1, p2 / v2)); <span class="comment">// cross each other</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> l = <span class="number">0</span>, r = inf, mid;</span><br><span class="line">    <span class="keyword">while</span> (!sgn(l, r)) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = min(ans, mid);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">int</span> _T = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; _T;</span><br><span class="line">    <span class="keyword">while</span> (_T--) solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<hr>
<h1><span id="g-fibonacci"> G. Fibonacci</span></h1>
<p>solved by Tryna. 0:16(+2)</p>
<p><strong>题意</strong> 定义<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g(x, y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>，当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo separator="true">⋅</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x ·y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.63889em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>为偶数时<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">g(x,y) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，求$$\sum_{i = 1}^{n}\sum_{j = i + 1}^{n}g(f_i, f_j)$$<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span>为斐波那契数列</p>
<p><strong>题解</strong> 答案为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mi>n</mi><mo>−</mo><mo stretchy="false">(</mo><mn>2</mn><mo>∗</mo><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>3</mn><mo stretchy="false">)</mo><mo>+</mo><mi>n</mi><mi>M</mi><mi>o</mi><mi>d</mi><mn>3</mn><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mn>2</mn><mo>∗</mo><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>3</mn><mo stretchy="false">)</mo><mo>+</mo><mi>n</mi><mi>M</mi><mi>o</mi><mi>d</mi><mn>3</mn><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{(n - 1) * n - (2 * (n / 3) + n Mod 3) * ((2 * (n / 3) + nMod   3 - 1))}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mbin mtight">∗</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mopen mtight">(</span><span class="mord mtight">2</span><span class="mbin mtight">∗</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mord mtight">/</span><span class="mord mtight">3</span><span class="mclose mtight">)</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">d</span><span class="mord mtight">3</span><span class="mclose mtight">)</span><span class="mbin mtight">∗</span><span class="mopen mtight">(</span><span class="mopen mtight">(</span><span class="mord mtight">2</span><span class="mbin mtight">∗</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mord mtight">/</span><span class="mord mtight">3</span><span class="mclose mtight">)</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">d</span><span class="mord mtight">3</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<details>
    <summary>AC代码</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">    ll ans = (n - <span class="number">1</span>) * n / <span class="number">2</span>;</span><br><span class="line">    ll cnt = (<span class="number">2</span> * (n / <span class="number">3</span>) + n % <span class="number">3</span>);</span><br><span class="line">    ll sum = cnt * (cnt - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans - sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<hr>
<h1><span id="i-sky-garden"> I. Sky Garden</span></h1>
<p>solved by Tryna.(-)</p>
<p><strong>题意</strong> 给出n个同心圆，每个圆被等分成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>m</mi></mrow><annotation encoding="application/x-tex">2m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault">m</span></span></span></span>份，求每个点到其他点最短距离之和</p>
<p><strong>题解</strong> 比赛的时候写到这题没时间了，然后赛后自己花了两个小时写出来了。这题的关键在于求出一个圆上每个点到其他点的最短距离和。想了一下本来想通过找规律来找到这个答案的，后来发现有点难实现，看了一下数据范围，发现可以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>来算出答案。对于一个点，它有两种方案，一种是走两条半径，另外一种是走圆弧。求出一个圆上所有点到其他点的最短距离和后，这个圆上的点要想到外面的大圆上，他至少需要经过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>（大圆的半径） - <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>（小圆的半径）的距离，想要距离最短，必须要走小圆的圆弧。可以发现小圆上的一个点到大圆上所有点的距离就是之前算出来的小圆上每个点到其他点的最短距离和加上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>m</mi><mo stretchy="false">(</mo><mi>R</mi><mo>−</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">2m(R - r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span>，知道了这些接下来随便乱搞一下就出来了，注意要特判<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">m = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的情况，因为此时圆心是没有交点的。代码写的比较长。</p>
<details>
    <summary>AC代码</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-8</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">double</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">if</span>(m == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">double</span> result = n * (n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                result += <span class="number">4</span> * j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.10f\n&quot;</span>, result);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">2</span> * m * (n * (n + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">double</span> c1 = <span class="number">0</span>, angle = <span class="number">1</span> / (<span class="number">2</span> * m), sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * m; i++)&#123;</span><br><span class="line">        angle = <span class="number">1.0</span> / (<span class="number">2</span> * m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= <span class="number">2</span> * m; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(angle - <span class="number">0.5</span> &gt; eps)</span><br><span class="line">                    c1 += min((<span class="keyword">double</span>)<span class="number">2</span>, <span class="number">2</span> * (<span class="number">1</span> - angle) * pi);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    c1 += min((<span class="keyword">double</span>)<span class="number">2</span>, <span class="number">2</span> * angle * pi);</span><br><span class="line">                angle += <span class="number">1.0</span> / (<span class="number">2</span> * m);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(angle - <span class="number">0.5</span> &gt; eps)&#123;</span><br><span class="line">                    sum += min((<span class="keyword">double</span>)<span class="number">2</span>, (<span class="number">1</span> - angle) * <span class="number">2</span> * pi);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> sum += min((<span class="keyword">double</span>)<span class="number">2</span>, <span class="number">2</span> * angle * pi);</span><br><span class="line">                angle += <span class="number">1.0</span> / (<span class="number">2</span> * m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sum += c1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">double</span> cnt = i * sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) cnt += <span class="number">2</span> * m * (<span class="number">2</span> * m * (j - i) + c1 * i);</span><br><span class="line">        ans += cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.10f\n&quot;</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<hr>
<h1><span id="l-traveling-in-the-grid-world"> L.  Traveling in the Grid World</span></h1>
<p>Solved By Sstee1XD. (-)</p>
<p><strong>题意</strong> 给你一个n行m列的方格，左上角为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0, 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>点。现在要从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0, 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>点走到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n, m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>点，走的规则如下：</p>
<ul>
<li>若两点之间不存在其他的整点，则能直接走，否则不能走</li>
<li>任意两次路线的斜率应该不同</li>
</ul>
<p>问你要走的最短距离是多少。</p>
<p><strong>题解</strong> 显然，当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">gcd(n, m) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时，直接输出。其余情况，不会证明，瞎猜一下要转一次得到最优答案。此时我们发现越往下面找答案会越大（三角形两边之和大于第三边），所以找到第一个点后就<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">break</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，最后输出最小的答案。</p>
<details>
    <summary>AC代码</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg(x...) do &#123; cout <span class="meta-string">&lt;&lt; #x &lt;&lt; &quot; -&gt; &quot;; err(x); &#125; while (0)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span>... <span class="title">Ts</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(<span class="keyword">const</span> T&amp; arg, <span class="keyword">const</span> Ts&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; arg &lt;&lt; <span class="string">&#x27; &#x27;</span>; err(args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f = <span class="number">0</span>; x = <span class="number">0</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = getchar()) f |= (ch == <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = getchar()) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (f) x = -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a == <span class="number">0</span>? b : gcd(b % a, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getDis</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(x * x + y * y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll n, m;</span><br><span class="line"><span class="keyword">double</span> k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">if</span> (gcd(n, m) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.10f\n&quot;</span>, getDis(n, m));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    k = (<span class="keyword">double</span>)m / (<span class="keyword">double</span>)n;</span><br><span class="line">    <span class="keyword">double</span> minn = n + m;</span><br><span class="line">    <span class="keyword">for</span> (ll _x = <span class="number">0</span>; _x &lt; n; ++_x) &#123;</span><br><span class="line">        ll _y = k * _x + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; _y &lt;= m; ++_y) &#123;</span><br><span class="line">            <span class="keyword">if</span> (gcd(_x, _y) != <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (n * _y == m * _x) <span class="keyword">continue</span>;</span><br><span class="line">            minn = min(minn, getDis(_x, _y) + getDis(n - _x, m - _y));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.10f\n&quot;</span>, minn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _T = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;_T);</span><br><span class="line">    <span class="keyword">while</span> (_T--) solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<hr>
<h1><span id="m-gitignore"> M. Gitignore</span></h1>
<p>solved by lllllan. 4:36(+1)</p>
<p><strong>题意</strong> 有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>个可折叠的文件和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>个不可折叠的文件，考虑<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>个可折叠的文件最后必须显示多少个。【比如<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">/</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">a/b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault">b</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">/</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">a/c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault">c</span></span></span></span>可折叠为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">a/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">/</span></span></span></span>，最后只需显示一个文件即可】</p>
<p><strong>题解</strong> 先对<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>个不可折叠的文件进行前缀标记【比如<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">/</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>c</mi><mi mathvariant="normal">/</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">a/b/c/d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">c</span><span class="mord">/</span><span class="mord mathdefault">d</span></span></span></span>文件是不可折叠的，则用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">map</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span></span></span></span>记录下<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">/</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">a/b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault">b</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">/</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">a/b/c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">c</span></span></span></span>均为不可折叠】。然后再遍历前<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>个可折叠的文件，对必须显示的文件进行计数，可以折叠成已有显示的文件进行忽略。</p>
<details>
    <summary>AC代码</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _T, n, m;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; mp, vis;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> s[<span class="number">100</span>];</span><br><span class="line">	mp.clear(), vis.clear();</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; s[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">		<span class="built_in">string</span> str;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">		<span class="keyword">int</span> len = str.size();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (str[j] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line"><span class="comment">//				cout &lt;&lt; str.substr(0, j) &lt;&lt; endl;</span></span><br><span class="line">				mp[str.substr(<span class="number">0</span>, j)] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> len = s[i].size();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= len; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (s[i][j] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">				<span class="built_in">string</span> tem = s[i].substr(<span class="number">0</span>, j);</span><br><span class="line">				<span class="keyword">if</span> (mp[tem]) flag = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (vis[tem]) flag = <span class="number">0</span>;</span><br><span class="line">					vis[tem] = <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ans += flag;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; _T;</span><br><span class="line">	<span class="keyword">while</span> (_T--) run();	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>]]></content>
      <categories>
        <category>比赛题解</category>
      </categories>
  </entry>
  <entry>
    <title>The 17th Zhejiang Provincial Collegiate Programming Contest</title>
    <url>/2021/02/22/The-17th-Zhejiang-Provincial-Collegiate-Programming-Contest/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th style="text-align:center">solved</th>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">C</th>
<th style="text-align:center">D</th>
<th style="text-align:center">E</th>
<th style="text-align:center">F</th>
<th style="text-align:center">G</th>
<th style="text-align:center">H</th>
<th style="text-align:center">I</th>
<th style="text-align:center">J</th>
<th style="text-align:center">K</th>
<th style="text-align:center">L</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">6 / 11</td>
<td style="text-align:center">O</td>
<td style="text-align:center">Ø</td>
<td style="text-align:center">Ø</td>
<td style="text-align:center">·</td>
<td style="text-align:center">Ø</td>
<td style="text-align:center">·</td>
<td style="text-align:center">·</td>
<td style="text-align:center">·</td>
<td style="text-align:center">O</td>
<td style="text-align:center">·</td>
<td style="text-align:center">O</td>
<td style="text-align:center">·</td>
</tr>
</tbody>
</table>
<ul>
<li>O：比赛时通过</li>
<li>Ø：赛后通过</li>
<li>!：比赛时尝试了未通过</li>
<li>·：比赛时未尝试</li>
</ul>
<p><strong>REPLY</strong> ： 由于自己的读题失误给队友造成了很大的麻烦，抱歉。-Sstee1XD</p>
<h2 id="比赛链接"><a class="markdownIt-Anchor" href="#比赛链接"></a> <a href="https://codeforces.com/gym/102770">比赛链接</a></h2>
<span id="more"></span>
<h1 id="a-ad-2020"><a class="markdownIt-Anchor" href="#a-ad-2020"></a> A. AD 2020</h1>
<p>solved by Tryna &amp; Sstee1XD. 1:44(+1)</p>
<p><strong>题意</strong> 给你起始日期和终止日期，问你其中有多少个日期构成的字符串中包含<code>202</code>。</p>
<p><strong>题解</strong> 预处理下前缀和，然后处理下边边角角。</p>
<details>
    <summary>AC代码</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[<span class="number">10005</span>], y1, m1, d1, y2, m2, d2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkY</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (y / <span class="number">1000</span> == <span class="number">2</span> &amp;&amp; y / <span class="number">100</span> % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; y / <span class="number">10</span> % <span class="number">10</span> == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (y / <span class="number">100</span> % <span class="number">10</span> == <span class="number">2</span> &amp;&amp; y / <span class="number">10</span> % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; y % <span class="number">10</span> == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkLeap</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> (y % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; y % <span class="number">100</span> != <span class="number">0</span>) || y % <span class="number">400</span> == <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2000</span>; i &lt;= <span class="number">9999</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (checkY(i)) &#123;</span><br><span class="line">            num[i] = <span class="number">365</span> + checkLeap(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">10</span> == <span class="number">2</span>) num[i] = <span class="number">29</span> + checkLeap(i);</span><br><span class="line">        <span class="keyword">else</span> num[i] = <span class="number">2</span>;</span><br><span class="line">        num[i] += num[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> m, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (checkY(y)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span> || i == <span class="number">3</span> || i == <span class="number">5</span> || i == <span class="number">7</span> || i == <span class="number">8</span> || i == <span class="number">10</span>) res += <span class="number">31</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>) res += <span class="number">28</span> + checkLeap(y);</span><br><span class="line">            <span class="keyword">else</span> res += <span class="number">30</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res += d;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (y % <span class="number">10</span> == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m &gt; <span class="number">2</span>) res += <span class="number">28</span> + checkLeap(y);</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">2</span>) res += d;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">12</span>) res += (d &gt;= <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m &gt; <span class="number">2</span>) res += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">2</span>) res += (d &gt;= <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">12</span>) res += (d &gt;= <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; y1 &gt;&gt; m1 &gt;&gt; d1 &gt;&gt; y2 &gt;&gt; m2 &gt;&gt; d2;</span><br><span class="line">    ans = num[y2 - <span class="number">1</span>] - num[y1 - <span class="number">1</span>];</span><br><span class="line">    ans += add(y2, m2, d2) - add(y1, m1, d1);</span><br><span class="line">    <span class="keyword">if</span> (checkY(y1) || (y1 % <span class="number">10</span> == <span class="number">2</span> &amp;&amp; m1 == <span class="number">2</span>) || (m1 == <span class="number">2</span> &amp;&amp; d1 == <span class="number">2</span>) || (m1 == <span class="number">12</span> &amp;&amp; d1 == <span class="number">2</span>)) ans += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> _T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; _T;</span><br><span class="line">    <span class="keyword">while</span> (_T--) solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<hr />
<h1 id="b-bin-packing-problem"><a class="markdownIt-Anchor" href="#b-bin-packing-problem"></a> B. Bin Packing Problem</h1>
<p>solved by Sstee1XD. (-)</p>
<p><strong>题意</strong>：给你<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个物品和它们的体积，还有容量为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span>的集装箱，要求按它给你的顺序放在集装箱里。现有两种方案。</p>
<ul>
<li>第一种：每次在现有的集装箱里从左到右扫一遍，放到第一个能放进去的集装箱里，如果没有则在最右边加一个集装箱放。</li>
<li>第二种：每次在现有的集装箱里选择剩余容量最接近当前物品的集装箱，如果没有则在最右边加一个集装箱放。</li>
</ul>
<p>输出两种方案下使用集装箱的数量。</p>
<p><strong>题解</strong>：对于两种方案来说，遍历肯定会超时。对于第一种方案，因为要找能放下的最左边的箱子，所以用<code>线段树</code>来维护区间最大值，每次都优先去左子树。<br />
对于第二种方案，我们要找容量大于等于当前物品体积且最接近的集装箱，很容易想到去<code>二分</code>顺序排列的容器来实现。为了实现有序，选择用<code>multiset</code>来存储数据，比在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">set</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span></span></span>里用结构体会方便很多。</p>
<details>
    <summary>AC代码</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, c, ans, a[maxn];</span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SEG</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> t[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		t[id] = max(t[id &lt;&lt; <span class="number">1</span>], t[id &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> id , <span class="keyword">int</span> l , <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">		t[id] = c;</span><br><span class="line">		<span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		build(id &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">		build(id &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>,  r);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">			<span class="keyword">if</span> (t[id] == c) ans++;</span><br><span class="line">			t[id] -= v;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (t[id &lt;&lt; <span class="number">1</span>] &gt;= v) modify(id &lt;&lt; <span class="number">1</span>, l, mid, v);</span><br><span class="line">		<span class="keyword">else</span> modify(id &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, v);</span><br><span class="line">		up(id);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;seg;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; c;</span><br><span class="line">	ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">	seg.build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		seg.modify(<span class="number">1</span>, <span class="number">1</span>, n, a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	st.clear();</span><br><span class="line">	<span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; :: iterator it;</span><br><span class="line">	st.insert(c - a[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		it = st.lower_bound(a[i]);</span><br><span class="line">		<span class="keyword">if</span> (it == st.end()) &#123;</span><br><span class="line">			st.insert(c - a[i]);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> v = *it - a[i];</span><br><span class="line">		st.erase(it);</span><br><span class="line">		st.insert(v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; st.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> _T;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; _T;</span><br><span class="line">	<span class="keyword">while</span> (_T--) solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<hr />
<h1 id="c-crossword-validation"><a class="markdownIt-Anchor" href="#c-crossword-validation"></a> C. Crossword Validation</h1>
<p>solved by SsteelXD. (-)</p>
<p><strong>题意</strong>：给你一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>∗</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n * n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>的矩阵和m个单词以及单词的权值，问矩阵中横着和竖着的，有#隔开的极长单词是否都在给你<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>个单词中出现过，以及它们的权值和是多少。</p>
<p><strong>题解</strong>：用字典树来记录<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>个单词以及它们的权值，之后遍历矩阵查找。</p>
<details>
    <summary>AC代码</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">4e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> maps[<span class="number">1010</span>][<span class="number">1010</span>], tmp[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> nx[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">        <span class="keyword">int</span> cnt;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">memset</span>(nx, <span class="number">-1</span>, <span class="keyword">sizeof</span> nx);</span><br><span class="line">            v = <span class="number">0</span>;</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;t[maxn];</span><br><span class="line">    <span class="keyword">int</span> root, tot;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ++tot;</span><br><span class="line">        t[tot].init();</span><br><span class="line">        <span class="keyword">return</span> tot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">        root = newnode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">int</span> now = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t[now].nx[s[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">-1</span>) &#123;</span><br><span class="line">                t[now].nx[s[i] - <span class="string">&#x27;a&#x27;</span>] = newnode();</span><br><span class="line">            &#125;</span><br><span class="line">            now = t[now].nx[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        t[now].v += v;</span><br><span class="line">        t[now].cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">int</span> now = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> ch = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (t[now].nx[ch] == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            now = t[now].nx[ch];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t[now].cnt == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> t[now].v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;trie;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gao</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (maps[i][j] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span> (maps[i][j] != <span class="string">&#x27;#&#x27;</span> &amp;&amp; j &lt;= n) &#123;</span><br><span class="line">                tmp[len++] = maps[i][j++];</span><br><span class="line">            &#125;</span><br><span class="line">            tmp[len] = <span class="number">0</span>;</span><br><span class="line">            ll now = trie.query(tmp);</span><br><span class="line">            <span class="keyword">if</span> (now == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            res += now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (maps[i][j] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span> (maps[i][j] != <span class="string">&#x27;#&#x27;</span> &amp;&amp; i &lt;= n) &#123;</span><br><span class="line">                tmp[len++] = maps[i++][j];</span><br><span class="line">            &#125;</span><br><span class="line">            tmp[len] = <span class="number">0</span>;</span><br><span class="line">            ll now = trie.query(tmp);</span><br><span class="line">            <span class="keyword">if</span> (now == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            res += now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    trie.init();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, maps[i] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, v; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s %d&quot;</span>, tmp, &amp;v);</span><br><span class="line">        trie.insert(tmp, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, gao());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;_T);</span><br><span class="line">    <span class="keyword">while</span> (_T--) solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<hr />
<h1 id="e-easy-dp-problem"><a class="markdownIt-Anchor" href="#e-easy-dp-problem"></a> E. Easy DP Problem</h1>
<p>sloved by Tryna. (-)</p>
<p><strong>题解:</strong> 根据dp公式，容易得出最后的答案为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>r</mi><mo>−</mo><mi>l</mi><mo>+</mo><mn>1</mn></mrow></msubsup><msup><mi>i</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\sum_{i=1}^{r-l+1} i^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2887179999999998em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9890079999999999em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> + 前<strong>k</strong>大之和，前面一个平方和为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>6</mn></mrow><annotation encoding="application/x-tex">n * (n + 1) * (2n + 1) / 6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">6</span></span></span></span>，后面前k大之和可以用主席树维护</p>
<details>
    <summary>AC代码</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], t, n, q;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">int</span> cnt, root[N];</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    ll sum;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">&#125;hjt[N * <span class="number">40</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getid</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> lower_bound(v.begin(), v.end(), x) - v.begin() + <span class="number">1</span>; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> pre, <span class="keyword">int</span> &amp;now, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    now = ++cnt;</span><br><span class="line">    hjt[now] = hjt[pre];</span><br><span class="line">    hjt[now].num++; hjt[now].sum += val;</span><br><span class="line">    <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">        hjt[now].val = val;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(p &lt;= m) insert(hjt[pre].l, hjt[now].l, l, m, p, val);</span><br><span class="line">    <span class="keyword">else</span> insert(hjt[pre].r, hjt[now].r, m + <span class="number">1</span>, r, p, val);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> hjt[R].val * k;</span><br><span class="line">    <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp = hjt[hjt[R].r] .num - hjt[hjt[L].r].num;</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= tmp) <span class="keyword">return</span> query(hjt[L].r, hjt[R].r, m + <span class="number">1</span>, r, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> hjt[hjt[R].r].sum - hjt[hjt[L].r].sum + query(hjt[L].l, hjt[R].l, l, m, k - tmp);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    v.clear();</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        v.push_back(a[i]); root[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(v.begin(), v.end());</span><br><span class="line">    v.erase(unique(v.begin(), v.end()), v.end());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	init(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = getid(a[i]);</span><br><span class="line">        insert(root[i - <span class="number">1</span>], root[i], <span class="number">1</span>, n, t, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q);</span><br><span class="line">	<span class="keyword">while</span>(q--) &#123;</span><br><span class="line">		<span class="keyword">int</span> l, r, k;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;k);</span><br><span class="line">		<span class="keyword">int</span> u = r - l + <span class="number">1</span>;</span><br><span class="line">		ll ans = query(root[l - <span class="number">1</span>], root[r], <span class="number">1</span>, n, k);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (<span class="number">1ll</span>) * u * (u + <span class="number">1</span>) * (<span class="number">2</span> * u + <span class="number">1</span>) / <span class="number">6</span> + ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">		run();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</details>
<hr />
<h1 id="k-killing-the-brute-force"><a class="markdownIt-Anchor" href="#k-killing-the-brute-force"></a> K. Killing the Brute-force</h1>
<p>solved by Tryna.00:14(+)</p>
<p>签到题</p>
<details>
    <summary>AC代码</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;    </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>((<span class="keyword">double</span>)(<span class="number">-1</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-8</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="keyword">int</span> moven1[<span class="number">10</span>][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;&#125;; </span><br><span class="line"><span class="keyword">int</span> moven2[<span class="number">10</span>][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> t, n, a[maxn], b[maxn];  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// ios::sync_with_stdio(false);</span></span><br><span class="line">    <span class="comment">// cin.tie(0);cout.tie(0);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">            a[i] = a[i] * <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line">            <span class="keyword">if</span>(p) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[i] &lt; b[i]) p = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<hr />
<h1 id="iinvoking-the-magic"><a class="markdownIt-Anchor" href="#iinvoking-the-magic"></a> I.Invoking the Magic</h1>
<p>solved by lllllan.01:28(+1)</p>
<p><strong>题意：</strong> 现有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>双袜子，但是被混合起来了，即一组袜子中可能是两只不同的袜子。宝宝有魔法能够将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>组袜子重新匹配，使得这<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>组袜子中相同的袜子分到一起。要求是这<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>组中的袜子必须能够匹配，不能出现单只独一无二的袜子。求能够将所有袜子重新匹配的最小<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>。</p>
<p><strong>题解：</strong> 只有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi>e</mi><mn>5</mn></mrow><annotation encoding="application/x-tex">1e5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault">e</span><span class="mord">5</span></span></span></span>双袜子，但是袜子的编号却是叛逆的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>30</mn></msup></mrow><annotation encoding="application/x-tex">2^{30}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>，所以需要离散化一下，当时的第一反应就是用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">map</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span></span></span></span>来重新赋予编号，交一发就直接<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span>了嘞。最后靠队友改成了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mi>n</mi><mi>o</mi><mi>r</mi><mi>d</mi><mi>e</mi><mi>r</mi><mi>e</mi><mi>d</mi><mi mathvariant="normal">_</mi><mi>m</mi><mi>a</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">unordered\_map</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span></span></span></span>就过了.</p>
<details>
    <summary>AC代码</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _T, n, a, b, maxsize;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; s, num;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;	maxsize = <span class="number">0</span>; s.clear(), num.clear();&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;	<span class="keyword">return</span> s[x] == x ? x : s[x] = find(s[x]);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;	<span class="keyword">if</span>(s[a] == <span class="number">0</span>) &#123; s[a] = a; num[a] = <span class="number">1</span>;&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">un</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	a = find(a), b = find(b);</span><br><span class="line">	<span class="keyword">if</span>(a == b)	<span class="keyword">return</span> ;</span><br><span class="line">	s[b] = a, num[a] += num[b];</span><br><span class="line">	<span class="keyword">if</span>(num[a] &gt; maxsize) maxsize = num[a];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	init();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">while</span>(n--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">		check(a);</span><br><span class="line">		check(b);</span><br><span class="line">		un(a, b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, maxsize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;_T);</span><br><span class="line">	<span class="keyword">while</span>(_T--) run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>]]></content>
      <categories>
        <category>比赛题解</category>
      </categories>
  </entry>
  <entry>
    <title>first blog / 博客初建起</title>
    <url>/2021/02/22/first-blog/</url>
    <content><![CDATA[<p><sub>折腾了一个上午，才算是搭建了一个简陋的个人博客。<br>
为了防止过两天连自己的博客都更新不了的意外发生，这里<s>记录</s>搬运一些hexo的指令。Orz</sub></p>
<p>小白第一步，win+r，打开cmd。<s>到目录D/blog/下开始。</s> 这是我自己的文件位置。</p>
<span id="more"></span>
<h1><span id="yelee主题使用说明"> </span></h1>
<h1><span id="新建一篇文章"> 新建一篇文章</span></h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo n &quot;博客名&quot;</span><br></pre></td></tr></table></figure>
<p>引号中当然是你希望新建的文章的标题了，然后就会在/source/_posts/目录下为你新建一个同名的md文件。</p>
<p>新建文章模板</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: My awesome title</span><br><span class="line">date: 2016-10-12 18:38:45</span><br><span class="line">categories: </span><br><span class="line">    - 分类1</span><br><span class="line">    - 分类2</span><br><span class="line">tags: </span><br><span class="line">    - 标签1</span><br><span class="line">    - 标签2</span><br><span class="line">mp3: http:&#x2F;&#x2F;domain.com&#x2F;awesome.mp3</span><br><span class="line">cover: http:&#x2F;&#x2F;domain.com&#x2F;awesome.jpg</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h1><span id="开始写博客"> 开始写博客</span></h1>
<p>有vim或者notepad的，可以直接用命令语句打开，形如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim 博客名.md</span><br><span class="line">notepad 博客名.md</span><br></pre></td></tr></table></figure>
<p>其实没有这两个软件也没关系，记事本写也是一样的/doge。反正根据自己的喜好和需求，有一个能过比较顺手地写markdown的软件即可，然后根据/source/_posts/目录找到该文章然后进行编写即可。</p>
<h1><span id="文章写好部署网站"> 文章写好部署网站</span></h1>
<p>生成静态文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<p>启动服务器。默认情况下，访问网址为： <a href="http://localhost:4000/%E3%80%82">http://localhost:4000/。</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>部署网站</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<h1><span id="清除缓存文件"> 清除缓存文件</span></h1>
<p>清除缓存文件 (db.json) 和已生成的静态文件 (public)。<br>
在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>hexo实现文章间跳转</title>
    <url>/2021/02/22/hexo%E5%AE%9E%E7%8E%B0%E6%96%87%E7%AB%A0%E9%97%B4%E8%B7%B3%E8%BD%AC/</url>
    <content><![CDATA[<p>比如我想附上自己博客的这篇文章<code>【Fahaxiki！】的训练实录</code></p>
<p>它在我电脑上的文件名为<code>【Fahaxiki！】的训练实录.md</code></p>
<p>实现语句为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% post_link 【Fahaxiki！】的训练实录 【Fahaxiki！】的训练实录%&#125;</span><br></pre></td></tr></table></figure>
<a href="/2021/02/22/%E3%80%90Fahaxiki%EF%BC%81%E3%80%91%E7%9A%84%E8%AE%AD%E7%BB%83%E5%AE%9E%E5%BD%95/" title="【Fahaxiki！】的训练实录">【Fahaxiki！】的训练实录</a>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>【Fahaxiki！】的训练实录</title>
    <url>/2021/02/22/%E3%80%90Fahaxiki%EF%BC%81%E3%80%91%E7%9A%84%E8%AE%AD%E7%BB%83%E5%AE%9E%E5%BD%95/</url>
    <content><![CDATA[<p><strong>队霸：</strong><a href="https://me.csdn.net/ssteelxd">Sstee1XD</a> <strong>主代码手：</strong><a href="https://me.csdn.net/weixin_47900150">Tryna</a> <strong>后勤保障人员：</strong><a href="https://blog.csdn.net/m0_46187157">lllllan</a></p>
<p>【Some considerations】</p>
<ul>
<li><strong>读题。</strong> 已经不是第一次，代码写好，提交，修改，如此”努力“了半天之后，发现题意读错了。<strong>当一个人上机的时候，其他人不要着急读新题，至少留一个人再确认一下题意，然后帮忙思考一些极端情况、提供一些测试样例。</strong></li>
<li><strong>尽量避免一个人陷进去。</strong> 一方面是整体的知识储备不够，遇到有些题目可能只有一个人能做，但是任由一个人单挑又具有很大难度，<strong>除了做题补提还要留一些时间填补知识空缺，尽量保证一道题有两个人可以相互讨论，确保思路的正确性和代码的可行性。</strong> 另一方面是训练不够，以及意气用事，做不出来还行死磕，<strong>比赛初阶段，尽量避免长时间陷入一道题无法自拔，队友劝退让其读新题；比赛后期可以全队一起攻克。</strong></li>
<li>打比赛时一定一定不能传递负能量，题目wa了没有关系，千万不能说<strong>完了完了</strong>之类的话</li>
<li>实在找不到自己的错误，请考虑及时让队友重写。</li>
</ul>
<hr />
<span id="more"></span>
<p><strong>正式比赛：</strong><br />
2020-10-17：<strong>3/12，rank:119/436（铜）</strong>，打星参赛无奖 <a href="/2021/02/22/The-17th-Zhejiang-Provincial-Collegiate-Programming-Contest/" title="The 17th Zhejiang Provincial Collegiate Programming Contest">The 17th Zhejiang Provincial Collegiate Programming Contest</a><br />
2020-12-13：<strong>3/13，rank:354/635（铁）</strong>，<a href="/2021/02/22/2020-ACM-ICPC-Asia-Shanghai-Regional/" title="2020 ACM-ICPC, Asia Shanghai Regional">2020 ACM-ICPC, Asia Shanghai Regional</a></p>
<p>后续内容待博客搬家后更新</p>
]]></content>
  </entry>
  <entry>
    <title>树形相关</title>
    <url>/2021/02/23/%E6%A0%91%E5%BD%A2%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<img src="/2021/02/23/%E6%A0%91%E5%BD%A2%E7%9B%B8%E5%85%B3/无字之书.jpg" width="23%">
<span id="more"></span>
<h1><span id="对树的大概认识"> 对【树】的大概认识</span></h1>
<h2><span id="树的定义"> 树的定义</span></h2>
<p>【百度百科上是这样说的】</p>
<p>  <s>树，木本植物之总名，主要由根、干、枝、叶、花、果组成。</s> <img src="/2021/02/23/%E6%A0%91%E5%BD%A2%E7%9B%B8%E5%85%B3/头大.jpg" width="3%"></p>
<p>  树是一种<strong>数据结构</strong>，它是由<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>&gt;</mo><mo>=</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n(n&gt;=1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>个有限结点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p>
<ul>
<li>每个结点有零个或多个子结点；</li>
<li>没有父结点的结点称为根结点；</li>
<li>每一个非根结点有且只有一个父结点；</li>
<li>除了根结点外，每个子结点可以分为多个不相交的子树</li>
</ul>
<center>
<img src="/2021/02/23/%E6%A0%91%E5%BD%A2%E7%9B%B8%E5%85%B3/图一-树.jpg" width="60%" div align="center">
</center>
<h2><span id="树的种类"> 树的种类</span></h2>
<ul>
<li>无序树：树中任意节点的子结点之间没有顺序关系，这种树称为无序树,也称为自由树【说人话就是一棵还没有确定谁是根的树，再说的直白点就是一个没有回路的连通图】</li>
<li>有序树：树中任意节点的子结点之间有顺序关系，这种树称为有序树</li>
<li><strong>二叉树</strong>：每个节点最多含有两个子树的树称为二叉树</li>
<li><strong>满二叉树</strong>：叶节点除外的所有节点均含有两个子树的树被称为满二叉树
<ul>
<li>国内的定义：树中每一层的节点树都到达最大值，外观上就像一个三角形</li>
<li>国外的定义：对于树中的任意节点，要么度数为0，要么度数为2</li>
</ul>
</li>
<li><strong>完全二叉树</strong>：如果对满二叉树的结点进行编号, 约定编号从根结点起, 自上而下, 自左而右。则深度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>的, 有n个结点的二叉树, 当且仅当其每一个结点都与深度为k的满二叉树中编号从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">至</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">1至n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord cjk_fallback">至</span><span class="mord mathdefault">n</span></span></span></span>的结点一一对应时, 称之为完全二叉树。【说人话呢就是一棵树抛开最后一层不看，剩余部分满足一颗满二叉树的定义；并且最后一层的节点是从左到右紧密排好的】</li>
<li>哈夫曼树（最优二叉树）：带权路径最短的二叉树称为哈夫曼树或最优二叉树</li>
</ul>
<center>
<img src="/2021/02/23/%E6%A0%91%E5%BD%A2%E7%9B%B8%E5%85%B3/图二-二叉树.jpg" width="60%" div align="center">
</center>
<h2><span id="相关术语"> 相关术语</span></h2>
<ul>
<li><strong>结点</strong>：包含一个数据元素及若干指向子树分支的信息</li>
<li><strong>结点的度</strong>：一个结点拥有子树的数目称为结点的度</li>
<li><strong>叶子结点</strong>：也称为终端结点，没有子树的结点或者度为零的结点</li>
<li><strong>分支结点</strong>：也称为非终端结点，度不为零的结点称为非终端结点</li>
<li><strong>树的度</strong>：树中所有结点的度的最大值</li>
<li><strong>结点的层次</strong>：从根结点开始，假设根结点为第1层，根结点的子节点为第2层，依此类推，如果某一个结点位于第L层，则其子节点位于第L+1层</li>
<li><strong>树的深度</strong>：也称为树的高度，树中所有结点的层次最大值称为树的深度</li>
<li><strong>权值：</strong> 边权、点权</li>
</ul>
<center>
<img src="/2021/02/23/%E6%A0%91%E5%BD%A2%E7%9B%B8%E5%85%B3/图三-相关术语.jpg" width="50%" height="30%">
</center>
<h2><span id="二叉树的遍历"> 二叉树的遍历</span></h2>
<p>  前、中、后 三序遍历，针对的是根节点的位置。根-左-右即前序遍历【所谓先遍历根节点，所以是前序】；左-根-右即中序遍历；左-右-根即后序遍历；而层序遍历则是按层数从低到高，从左到右的顺序遍历。</p>
<center>
<img src="/2021/02/23/%E6%A0%91%E5%BD%A2%E7%9B%B8%E5%85%B3/图四-二叉树的遍历.jpg" width="50%">
</center>
<details>
    <summary>哦，还有一般的树的遍历：</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt, head[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span> <span class="keyword">int</span> v, w, next; &#125; e[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123; e[++cnt] = &#123;v, w, head[u]&#125;; head[u] = cnt; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next) &#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].v, w = e[i].w;</span><br><span class="line">		<span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d -(%d)-&gt; %d\n&quot;</span>, u, w, v);</span><br><span class="line">		DFS(v, u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> u, v, w; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">		add(u, v, w); add(v, u, w);</span><br><span class="line">	&#125;</span><br><span class="line">	DFS(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span> <span class="keyword">int</span> v, w; &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; G[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> v = G[u][i].v, w = G[u][i].w;</span><br><span class="line">		<span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d -(%d)-&gt; %d\n&quot;</span>, u, w, v);</span><br><span class="line">		DFS(v, u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> u, v, w; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">		G[u].push_back(&#123;v, w&#125;);</span><br><span class="line">		G[v].push_back(&#123;u, w&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	DFS(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">1 2 1</span></span><br><span class="line"><span class="comment">1 3 1</span></span><br><span class="line"><span class="comment">2 4 1</span></span><br><span class="line"><span class="comment">2 5 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</details>
<h1><span id="树形相关的回顾"> 【树形相关】的回顾</span></h1>
<h2><span id="线段树"> 线段树</span></h2>
<p>  线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。</p>
<ul>
<li>建树</li>
<li>单点修改</li>
<li>区间修改</li>
<li>区间查询</li>
</ul>
<center>
<img src="/2021/02/23/%E6%A0%91%E5%BD%A2%E7%9B%B8%E5%85%B3/图五-线段树.jpg" width="50%">
</center>
<h2><span id="最小生成树"> 最小生成树</span></h2>
<p>  一个有 n 个结点的连通图的生成树是原图的极小连通子图，且包含原图中的所有 n 个结点，并且有保持图连通的最少的边。</p>
<ul>
<li>Prim算法</li>
<li>Kruskal算法</li>
<li>次小生成树</li>
</ul>
<center>
<img src="/2021/02/23/%E6%A0%91%E5%BD%A2%E7%9B%B8%E5%85%B3/图六-最小生成树.jpg" width="50%">
</center>
<h2><span id="最近公共祖先"> 最近公共祖先</span></h2>
<p>  对于有根树T的两个结点u、v，最近公共祖先LCA(T,u,v)表示一个结点x，满足x是u和v的祖先且x的深度尽可能大。在这里，一个节点也可以是它自己的祖先。</p>
<ul>
<li>在线倍增【略】</li>
<li>离线Tarjan【略】</li>
</ul>
<h1><span id="今天的学习"> 今天的学习</span></h1>
<h2><span id="树上差分"> 树上差分</span></h2>
<p>  就是在树上进行差分，以起到优化复杂度的目的。主要作用是对树上的路径进行修改和查询操作，在<strong>修改多、查询少</strong>的情况下复杂度比较优秀。实际上，树上差分能够实现的操作，用<strong>线段树、树剖、LCT等等</strong>也可以实现，但它的优势在于实现简单，可以避免在考场上出现写题五分钟、调试两小时的情况</p>
<h3><span id="差分与前缀和"> 【差分】与【前缀和】</span></h3>
<ul>
<li>前缀和：数组中前<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>个数的和</li>
<li>差分：数组中第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>个数和前一个数的差</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">原数组</th>
<th style="text-align:center">9</th>
<th style="text-align:center">4</th>
<th style="text-align:center">7</th>
<th style="text-align:center">5</th>
<th style="text-align:center">9</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">前缀和</td>
<td style="text-align:center">9</td>
<td style="text-align:center">9 + 4 = 13</td>
<td style="text-align:center">13 + 7 = 20</td>
<td style="text-align:center">20 + 5 = 25</td>
<td style="text-align:center">25 + 9 = 34</td>
</tr>
<tr>
<td style="text-align:center">差分数组</td>
<td style="text-align:center">9</td>
<td style="text-align:center">4 - 9 = -5</td>
<td style="text-align:center">7 - 4 = 3</td>
<td style="text-align:center">5 - 7 = -2</td>
<td style="text-align:center">9 - 5 = 4</td>
</tr>
<tr>
<td style="text-align:center">前缀和的差分数组</td>
<td style="text-align:center"><strong>9</strong></td>
<td style="text-align:center">13 - 9 = <strong>4</strong></td>
<td style="text-align:center">20 - 13 = <strong>7</strong></td>
<td style="text-align:center">25 - 20 = <strong>5</strong></td>
<td style="text-align:center">34 - 25 = <strong>9</strong></td>
</tr>
<tr>
<td style="text-align:center">差分数组的前缀和</td>
<td style="text-align:center"><strong>9</strong></td>
<td style="text-align:center">9 - 5 = <strong>4</strong></td>
<td style="text-align:center">4 + 3 = <strong>7</strong></td>
<td style="text-align:center">7 - 2 = <strong>5</strong></td>
<td style="text-align:center">5 + 4 = <strong>9</strong></td>
</tr>
</tbody>
</table>
<p>  <strong>原数组的前缀和的差分数组就是原数组，原数组的差分数组的前缀和还是原数组。</strong> 这就是差分与前缀和互为逆运算的原因，也是差分可以用来优化操作的原因。实际上，差分优化和前缀和优化原理类似，只是实现相反。前缀和优化常常对前缀和数组作差，差分优化也常常对差分数组求前缀和。</p>
<p>  那就要问了，加和减也是互逆运算，乘和除也是互逆运算呢，不过都是一些很基础的运算而已。这里的前缀和和差分到底有什么运用呢。</p>
<blockquote>
<p> 例题：有一个区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span>的数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>。每次操作可以对某个区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[x,y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span>上的所有数字<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">+</span><span class="mord">1</span></span></span></span>。若干次操作之后询问<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">a_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的值。</p>
</blockquote>
<p>  一看区间修改加查询，可能就有些人马上会反应到用【线段树】来做了。前文就有讲到，差分应用于<strong>修改多、查询少</strong>的题目，对比线段树等算法的优势就在于实现简单。</p>
<p>  对于原数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">a[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span>，查询无非就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">a_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，但是修改需要暴力对整个区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[j,k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span>所有的数都进行修改。时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>∗</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n*m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>【假设有m次修改，每次修改整个区间】<br>
  假设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">sum[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span>是数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">a[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span>的前缀和，题目中求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">a_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>转换过来其实就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>−</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">sum[k] - sum[k - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>。但是实现区间修改，本质上还是要暴力去修改每一个相关的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">sum_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，时间复杂度上对比原先没有改变。<br>
  再看差分数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">d[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span>。根据性质来看，想要从差分数组得到原数组，那么在查询之前就需要对差分数组进行求前缀和，时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，貌似效率还变低了，<s>上当了</s>。反观修改操作，因为差分是原数组的后一个数减去前一个数，如果在某次修改操作中，区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[j,k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span>同时增加或减少了一定值，<strong>那么差分数组在区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>k</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[j + 1, k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span>上的值应该不受影响</strong>。所以一次区间修改只需要针对<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mi>j</mi></msub><mo separator="true">,</mo><msub><mi>d</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">d_j,d_{k+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>进行修改即可，时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。总体上看，时间复杂度优化到了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></p>
<p>比如对区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>2</mn><mo separator="true">,</mo><mn>6</mn><mo stretchy="false">]</mo><mi mathvariant="normal">上</mi><mi mathvariant="normal">所</mi><mi mathvariant="normal">有</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">都</mi><mo>+</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">[2,6]上所有的数都+3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mclose">]</span><span class="mord cjk_fallback">上</span><span class="mord cjk_fallback">所</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">都</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span></p>
<table>
<thead>
<tr>
<th style="text-align:center">下标</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th style="text-align:center">8</th>
<th style="text-align:center">9</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">原数组</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">差分数组</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">修改</td>
<td style="text-align:center">0</td>
<td style="text-align:center"><font color="blue">+3</font></td>
<td style="text-align:center"><font color="blue">+3</font></td>
<td style="text-align:center"><font color="blue">+3</font></td>
<td style="text-align:center"><font color="blue">+3</font></td>
<td style="text-align:center"><font color="blue">+3</font></td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">修改以后的原数组</td>
<td style="text-align:center">1</td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">修改以后的差分数组</td>
<td style="text-align:center">1</td>
<td style="text-align:center"><font color="red">3</font></td>
<td style="text-align:center"><font color="red">0</font></td>
<td style="text-align:center"><font color="red">0</font></td>
<td style="text-align:center"><font color="red">0</font></td>
<td style="text-align:center"><font color="red">0</font></td>
<td style="text-align:center"><font color="red">-3</font></td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<h3><span id="树上差分"> 树上差分</span></h3>
<p>  理解完差分以后，我们需要将差分试着应用到树上，这才是我们今天的课题。那对于一棵有可能有很多分支的树，我们的差分也只能是对于某一条分支的。【不再啰嗦，直接上图，只要记住两种差分的区别然后能过应用即可】</p>
<ul>
<li>从叶子节点向根节点的方向进行计算差分【为什么】</li>
<li>需要计算两点的LCA【倍增、Tarjan】</li>
</ul>
<p><strong>点的差分</strong></p>
<ul>
<li>对节点u到节点v路径上的所有节点的权值+c<br>
<code>w[u]+=c, w[v]+=c, w[lca&#123;u,v&#125;]-=c, w[fa[lca&#123;u,v&#125;]]-=c;</code></li>
</ul>
<center>
<img src="/2021/02/23/%E6%A0%91%E5%BD%A2%E7%9B%B8%E5%85%B3/图七-点的差分.jpg" width="50%">
</center>
<p><strong>边的差分</strong></p>
<ul>
<li>【假设u是v的父节点】将u与v边上的权值记到点v上</li>
<li>对节点u到节点v路径上所有的边的权值+c<br>
<code>w[u]+=c, w[v]+=c, w[lca&#123;u,v&#125;]-=2*c;</code></li>
</ul>
<center>
<img src="/2021/02/23/%E6%A0%91%E5%BD%A2%E7%9B%B8%E5%85%B3/图八-边的差分.jpg" width="50%">
</center>
<h2><span id="树的重心"> 树的重心</span></h2>
<p><strong>定义：</strong> 树的重心也叫树的质心。对于一棵树n个节点的无根树，找到一个点，其<font color="red">所有的子树中最大的子树节点数最少</font>，那么这个点就是这棵树的重心</p>
<p><strong>性质：</strong></p>
<ul>
<li>树中所有点到某个点的距离和中，到重心的距离和是最小的，如果有两个重心，他们的距离和一样。</li>
<li>把两棵树通过一条边相连，新的树的重心在原来两棵树重心的连线上。</li>
<li>一棵树添加或者删除一个节点，树的重心最多只移动一条边的位置。</li>
<li>一棵树最多有两个重心，且相邻。</li>
</ul>
<p><strong>算法：</strong></p>
<p>【算法思路】</p>
<ul>
<li>枚举每个节点作为根节点，去计算这个根节点下【【每个孩子节点作为根】的子树】的节点个数。</li>
<li>找到某个节点作为根节点时，它的最大子树节点最少，即为重心。</li>
</ul>
<p>【虽然但是】</p>
<ul>
<li>『枚举每个节点作为根节点』不可以也没必要，<s>那只是我陈述理论的时候方便理解而已。</s> 实际算法过程只需要假设一个节点作为根节点，<s>然后随便DFS一下就可以了。</s></li>
<li>DFS过程中去计算子树节点个数的时候，某一节点的孩子节点应该还包括它的【父节点】。听上去有些自相矛盾，但因为一开始的时候也只是随便假设了一个根节点，算是一个假根，所以一个节点的父节点也算得上是这个节点的【潜在孩子节点】。</li>
</ul>
<center>
<img src="/2021/02/23/%E6%A0%91%E5%BD%A2%E7%9B%B8%E5%85%B3/图九-求树的重心.jpg" width="30%">
</center>
<ul>
<li>定义<code>sz[i]</code>表示节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>为根的子树的节点个数。</li>
<li>定义<code>dp[i]</code>表示节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>为父节点的【所有孩子节点为根】的最大子树节点个数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">	sz[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next) &#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">		DFS(v, u);</span><br><span class="line">		sz[u] += sz[v];</span><br><span class="line">		dp[u] = max(dp[u], sz[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	dp[u] = max(dp[u], n - sz[u]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="树的直径"> 树的直径</span></h2>
<p><strong>定义：</strong> 树中所有最短路径距离的最大值即为树的直径</p>
<p>什么是距离？对于一棵带边权的树，距离就是边权；反之没有边权的树，相连接的两点的距离就默认为1。</p>
<center>
<img src="/2021/02/23/%E6%A0%91%E5%BD%A2%E7%9B%B8%E5%85%B3/图十-树的直径.jpg" width="30%">
</center>
<p><strong>算法：</strong> 选择任意一点开始DFS，找到离这个点最远的点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>；再从点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>开始DFS，找到离点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>最远的点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>。最后点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>到点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>的距离就是这棵树的直径。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> dis)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (dis &gt; ans) ans = dis, k = u;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next) &#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].c, w = e[i].w;</span><br><span class="line">		<span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">		DFS(v, u, dis + w);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="树的中心"> 树的中心</span></h2>
<p><strong>定义：</strong> 以树的中心为整棵树的根时，从该根到每个叶子节点的最长路径最短。<strong>区别于树的重心【<font color="red">重心下的最大子树节点数最小</font>】。</strong></p>
<h3><span id="算法一直径上暴力"> 算法一：直径上暴力</span></h3>
<p>根据定义，<s>废话，</s> 树的中心一定在树的直径上，所以在找到直径的两端点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mi mathvariant="normal">、</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">x、y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mord cjk_fallback">、</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>之后，离这两端点的<strong>最远距离最小</strong>【有点不说人话，总之就应该是最近的】的就是中心。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我是代码：</span></span><br><span class="line">······略</span><br></pre></td></tr></table></figure>
<h3><span id="算法二树形dp"> 算法二：树形DP</span></h3>
<p><strong>求什么？</strong></p>
<ul>
<li>树的中心，最长距离最小。</li>
<li>那就定义<code>dp[u]</code>表示到节点u的最长距离。</li>
</ul>
<center>
<img src="/2021/02/23/%E6%A0%91%E5%BD%A2%E7%9B%B8%E5%85%B3/图十一-求树的直径.jpg" width="20%">
</center>
<p><strong>怎么求？</strong></p>
<p>要想完成状态转移，势必需要遍历这棵树。</p>
<details>
    <summary>先看看DFS的特点</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i == <span class="number">10</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">	DFS(i + <span class="number">1</span>);</span><br><span class="line"><span class="comment">//	printf(&quot;%d\n&quot;, i);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	DFS(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<p>比如，想求某子树的根节点在树中的追远距离。那根节点的距离状态，就应该由孩子节点的距离转移获得。因此应该先递归，搞清楚孩子节点的距离，再来计算根节点的距离。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next) &#123;</span><br><span class="line">		<span class="keyword">int</span> v  = e[i].v, w = e[i].w;</span><br><span class="line">		<span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">		DFS(v, u);</span><br><span class="line">		dp[u] = max(dp[u], dp[v] + w);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>但是，一个节点到其他节点的距离，不止局限在子树内，</li>
</ul>
]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>树形DP</tag>
      </tags>
  </entry>
</search>
